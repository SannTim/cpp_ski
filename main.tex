\documentclass[openany, twoside, a4paper, 12pt]{extbook}
\usepackage[utf8]{inputenc}
\usepackage{rotating}
\usepackage[russian]{babel}
\usepackage{amsfonts} 
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx} 
\usepackage{subfig}
\usepackage{color}
\usepackage{svg}
\usepackage{epstopdf}
\usepackage[unicode]{hyperref}
\usepackage[nottoc]{tocbibind} 
\usepackage{verbatim}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage[colorinlistoftodos, prependcaption]{todonotes}
\usepackage{multirow}
\usepackage{algorithmic}
\usepackage{algorithm}

\author{Санников Тимофей Владимирович}
\title{Анализ времени выполнения широковещательного алгоритма прохождения критических секций}

\begin{document}
\maketitle

\section*{Постановка задачи}
Дана система из 64 процессов, каждый из которых располагается на отдельной ЭВМ,
подключённой к общей сети.
Все процессы одновременно инициируют запросы на вход в критическую секцию.
Целью является разработка программы,
реализующей широковещательный маркерный алгоритм для координации работы всех процессов,
а также вычисление временных характеристик выполнения этого алгоритма.

\section*{Алгоритм работы с критической секцией}
Критическая секция реализуется через файл-семафор `critical.txt`. Алгоритм работы представлен ниже.

\begin{algorithm}
\caption{Критическая секция}
\begin{algorithmic}[1]
\STATE Проверить наличие файла `critical.txt`.
\IF {файл существует}
    \STATE Сообщить об ошибке.
    \STATE Завершить выполнение программы.
\ELSE
    \STATE Создать файл `critical.txt`.
    \STATE Выполнить задержку (случайное время).
    \STATE Удалить файл `critical.txt`.
\ENDIF
\end{algorithmic}
\end{algorithm}

\subsection*{Описание маркерного алгоритма}
Маркерный алгоритм основан на широковещательной передаче запросов и последовательной передаче маркера между процессами.

\begin{itemize}
    \item Вход в критическую секцию.\\
    Процесс $P_k$, который хочет войти в критическую секцию,
	увеличивает свой локальный счётчик запросов $RN_k[k]$,
	после чего передаёт широковещательное сообщение с запросом,
	содержащим номер процесса ($k$) и текущий номер запроса ($Sn = RN_k[k]$).
	Если процесс уже обладает маркером, он может немедленно войти в критическую секцию.

    \item Обработка входящих запросов.\\
    При получении запроса от процесса $P_k$ процесс $P_j$ обновляет значение $RN_j[k]$ по формуле:
    \[
    RN_j[k] = \max(RN_j[k], Sn).
    \]
    Если процесс $P_j$ обладает свободным маркером, он передаёт его процессу $P_k$,
	если запрос $Sn$ является новым, то есть $RN_j[k] = LN[k] + 1$.

    \item Выход из критической секции.\\
    Процесс обновляет локальный счётчик $LN[k]$ маркера до значения $RN_k[k]$.
	Затем он добавляет идентификаторы всех процессов, запросы которых
	являются новыми~($RN_k[j] = LN[j] + 1$), в очередь запросов маркера.
	Если очередь запросов не пуста, маркер передаётся первому процессу в очереди.
\end{itemize}

\section*{Анализ времени выполнения алгоритма}
Для анализа времени выполнения алгоритма принимаются следующие параметры:
\begin{itemize}
    \item Время старта передачи (Ts):\\ 100 единиц времени.
    \item Время передачи одного байта (Tb):\\ 1 единица времени.
    \item Объём данных в запросе:\\ 8 байт (по 4 байта для номера процесса и номера запроса).
    \item Объём данных маркера: \\ Во-первых всегда передается вектор LN, для передачи которого необходимо N байт, 
	где N -- количество процессов. Во-вторых для передачи очереди необходимо передать сначала размер очереди,
	а затем саму очередь(это необходимо так как размер очереди динамический). Размер очереди может варьироваться от 
	0 до N-2 (исключается процесс владеющий маркером и процесс которому маркер отправляется). Так что, с учетом того, что 
	в нашем случае критическая секция проходится мгновенно, из-за чего многие из запросов просто не успевают дойти, 
	а в случае мгновенной отправки средняя длинна очереди была бы $(N-2)\div2$, можно уменьшить ориентировочную длинну очереди 
	до round($(N-2)\div4$)
	\item Время передачи данных при помощи Isend и Recv, передача данных происходит во время передачи маркера другому процессу,
		из-за чего на общее время выполнения оно влияет только в первый раз, чтобы очередь была не пуста, передаются они процессу,
		который изначально владеет маркером, а получить запросы он успеет только от соседних процессов, что по времени составляет $2 \cdot Tb$.
\end{itemize}

\subsection*{Формула вычисления времени}
Запросы отправляются параллельно с отправкой маркера, причем пересылка маркера в приоритете, поэтому
после первого полученного запроса все остальные считать не нужно(их пересылка будет происходить во время отправки маркера).
Общее время выполнения алгоритма рассчитывается как:
\begin{equation}
    \label{eq:total_time}
    T_{total} = Ts + 2 \cdot tb + N \cdot Tms + Tmz - Tb,
\end{equation}
где:
\begin{itemize}
    \item $Tmz = Tb \cdot 8$ — время отправки запроса,
	\item $Tms = Tb \cdot N + Tb  + Tb \cdot (round(N-2) \div 4)$ — время отправки маркера,
    \item $N$ — количество процессов.
\end{itemize}



\subsection*{Подстановка значений}
Для 64 процессов $N = 64$, $Tb = 1$, $Ts = 100$ формула~\ref{eq:total_time} принимает вид:
\[
	T_{total} = 100 + 2 + 64 \cdot (64 + 1 + round(64 - 2) \div 4) ) + 8 - 1.
\]
Расчёт даёт:
\[
T_{total} = 100 + 2 + 64 \cdot 81 + 8 - 1 = 5293.
\]

Итак, общее время выполнения алгоритма составляет $5293$ единиц времени.

\section*{Заключение}
В результате работы было реализовано программное решение,
использующее широковещательный маркерный алгоритм для координации процессов
при входе в критическую секцию. Выведена формула для оценки времени выполнения алгоритма и 
произведены расчёты для заданных параметров.
Получено, что для 64 процессов время выполнения составляет $5291$ единиц времени.
\end{document}

